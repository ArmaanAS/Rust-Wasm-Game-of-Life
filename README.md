<div align="center">
  <h1><code>Rust-Wasm-Game-of-Life</code></h1>

  <strong>A fast and efficient Conway's Game of Life simulation made with Rust & compiled for the web</strong>

  <h2><a href="#">Demo</a></h2>

</div>


# Tech

This game is a continuation of the [Rust Wasm Tutorial](https://rustwasm.github.io/docs/book/game-of-life/introduction.html). Like the tutorial, it uses wasm-pack to generate the bindings and the original frontend code template but both the rust and web code have been heavily modified. 


# Optimisations

Some optimisations have been added to the Rust game logic as well as the JavaScript rendering to make over a **x10 speedup**. It still uses a canvas element like the original tutorial but instead draws an image to the canvas, which is generated by the Rust code, in WASM. This alone reduced the render time by **10x**.

The game now uses 5 arrays instead of just a single cells array to:
1. Store the current cell states.
2. Store the previous cell states.
3. Store the alive neighbour counts.
4. Store the canvas / image array (u32 Vector of RGBA values, with hex representation <code>0xAABBGGRR</code>).
5. Store a statically generated rainbow colour grid (same size as cells array).

Storing the neighbour counts in a seperate array, instead of calling a function to count the alive neighbours, resulted in a **5x reduction** in tick time. Storing the previous cell states is purely used as a preallocated second buffer so that a new array doesn't need to be allocated. In an older version this also allowed for an optimisation in the canvas drawing method but that has since been optimised without it's use.

The latest version updates the canvas at the same time as it calculates the cells of the next tick. If the cell has changed state then so too will the canvas / image pixels. A simple optimisation. The canvas colours is either black if dead or the corresponding rainbow colour picked from the colour grid.